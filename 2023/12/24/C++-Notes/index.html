<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++ Notes | Welcome to LI LIANGJI's Blog</title><meta name="author" content="LI LIANGJI"><meta name="copyright" content="LI LIANGJI"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Initializer List Consider the following code 123456789101112131415class Dalin&#123;public:    Dalin(void) &#123; x &#x3D; 0; &#125;    Dalin(int x_) &#123; x &#x3D; x_; &#125;    int x;&#125;;class Erge&#123;pu">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Notes">
<meta property="og:url" content="http://example.com/2023/12/24/C++-Notes/index.html">
<meta property="og:site_name" content="Welcome to LI LIANGJI&#39;s Blog">
<meta property="og:description" content="Initializer List Consider the following code 123456789101112131415class Dalin&#123;public:    Dalin(void) &#123; x &#x3D; 0; &#125;    Dalin(int x_) &#123; x &#x3D; x_; &#125;    int x;&#125;;class Erge&#123;pu">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-12-23T15:23:29.000Z">
<meta property="article:modified_time" content="2024-01-04T17:14:20.842Z">
<meta property="article:author" content="LI LIANGJI">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/12/24/C++-Notes/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++ Notes',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-05 02:14:20'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Welcome to LI LIANGJI's Blog"><span class="site-name">Welcome to LI LIANGJI's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++ Notes</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-12-23T15:23:29.000Z" title="Created 2023-12-24 00:23:29">2023-12-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-01-04T17:14:20.842Z" title="Updated 2024-01-05 02:14:20">2024-01-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Programming-Language/">Programming Language</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++ Notes"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Initializer-List">Initializer List</h2>
<p>Consider the following code</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dalin</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dalin</span>(<span class="type">void</span>) &#123; x = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="built_in">Dalin</span>(<span class="type">int</span> x_) &#123; x = x_; &#125;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Erge</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Erge</span>() &#123; dalin.x = <span class="number">1024</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Dalin dalin;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>If we create an instance of class <code>Erge</code>, then the default-constructor of <code>Dalin</code> is called. Note that the member variable of <code>dalin</code> is initialized inside the constructor of <code>Erge</code>. That is, the member variable <code>x</code> is initialized twice. Imagine if you will that the default-constructor of <code>Dalin</code> incurs a significant overhead, so we need a way to avoid calls to default-constructor with a significant overhead.</p>
<p>The initializer list can help us avoid default-constructor.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Erge</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Erge</span>(<span class="type">void</span>) : <span class="built_in">dalin</span>(<span class="number">1024</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Dalin dalin;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>The initializer list is executed before the constructor body.</li>
<li>The order of initializer list is determined by the order in which the members are declared inside the class.</li>
</ul>
<h2 id="Namespace">Namespace</h2>
<p>Namespaces help prevent naming conflicts and improve code modularity by providing a way to encapsulate code.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mylib.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> liangji</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">const</span> std::string Dalin;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mylib.cxx</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> liangji</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> std::string Dalin = <span class="string">&quot;I&#x27;m Dalin, who are you?&quot;</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// namespace.cxx</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; liangji::<span class="built_in">square</span>(x) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; liangji::Dalin &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Lambda-Function">Lambda Function</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameter_list) -&gt; return_type &#123;</span><br><span class="line">    <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Breakdown:</p>
<ul>
<li><strong>Capture Clause (<code>[capture]</code>):</strong> Optional. It captures variables from the enclosing scope. It allows you to use variables from the surrounding context within the lambda function.</li>
<li><strong>Parameter List (<code>(parameter_list)</code>):</strong> Similar to the parameter list in a regular function. It declares parameters that the lambda function can take.</li>
<li><strong>Return Type (<code>-&gt; return_type</code>):</strong> Optional. It specifies the return type of the lambda function.</li>
<li><strong>Function Body:</strong> The actual code that gets executed when the lambda function is called.</li>
</ul>
<h3 id="Example-1">Example 1</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">x</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<h3 id="Example-2">Example 2</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [x]() -&gt; <span class="type">int</span> &#123;<span class="keyword">return</span> x * x;&#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<h3 id="Example-3">Example 3</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string msg = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> func = [msg, counter]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inside Lambda :: msg = &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inside Lambda :: counter = &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line">        msg = <span class="string">&quot;Temp&quot;</span>;</span><br><span class="line">        counter = <span class="number">20</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inside Lambda :: After changing :: msg = &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inside Lambda :: After changing :: counter = &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;msg = &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;counter = &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Note: changes made to <code>msg</code> and <code>counter</code> within the lambda do not affect the originals outside it.</strong></p>
<p>If you want to make change to a variable within the lambda, make use of pass reference</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Local Variables</span></span><br><span class="line">std::string msg = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">int</span> counter = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Defining Lambda function and Capturing Local variables by Reference</span></span><br><span class="line"><span class="keyword">auto</span> func = [&amp;msg, &amp;counter]() &#123;</span><br><span class="line">    <span class="comment">// Inside lambda, msg and counter refer to the original variables</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Variadic-Templates">Variadic Templates</h2>
<p>A variadic template is a template that can take an arbitrary number of arguments.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(T first, Args... args)</span></span>;</span><br></pre></td></tr></table></figure>
<p>In the above declaration, <code>Args...</code> represents a list of arguments.</p>
<p>Defining a variadic template function can be tricky, as you can’t access the variable number of arguments directly. You need to use recursion along with C++’s type deduction mechanism:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(T first, Args... args)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; first &lt;&lt; <span class="string">&quot; , &quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(args) &gt; <span class="number">0</span>)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">log</span>(args...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The <code>constexpr</code> keyword was introduced in C++11 to declare that a variable or function can be evaluated at compile time. This allows you to perform computations and use values that are known at compile time, leading to potentially more efficient code.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt;= <span class="number">1</span>) ? <span class="number">1</span> : n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> result = <span class="built_in">factorial</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Factorial of 5: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The result of a <code>constexpr</code> function or method can be stored in a non-<code>constexpr</code> variable, but the variable won’t be a constant expression, so it can not be evaluated at compile time.</p>
<p>The <code>if constexpr</code> statement, introduced in C++17, is an extension of the traditional <code>if</code> statement. It is part of a feature often referred to as “constexpr if” and is used to conditionally compile code <strong>at compile-time</strong>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral&lt;T&gt;::value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Integral type detected.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_floating_point&lt;T&gt;::value) </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Floating-point type detected.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Other type detected.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_info</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">/* Base case for the recursion */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_info</span><span class="params">(T first, Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; first;</span><br><span class="line">    <span class="comment">/* sizeof... is an operator to evaluate the number of an argument pack */</span></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(args) &gt; <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        <span class="built_in">print_info</span>(args...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print_info</span>(<span class="number">1</span>, <span class="number">1.2</span>, <span class="number">10U</span>, <span class="string">&quot;Dalin&quot;</span>, std::<span class="built_in">string</span>(<span class="string">&quot;Daliang&quot;</span>));</span><br><span class="line">    <span class="built_in">print_info</span>(<span class="number">1020ll</span>, (<span class="type">double</span>)<span class="number">1.23324</span>, <span class="number">123</span>, <span class="string">&quot;Chenge&quot;</span>, std::<span class="built_in">string</span>(<span class="string">&quot;Liangji&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="What-is-RAII">What is RAII</h2>
<p>RAII stands for <strong>Resource Acquisition Is Initialization</strong>. It is a programming idiom in C++ that helps manage resources (such as memory, file handles, network connections, etc.) by tying their lifecycle to the scope of an object. <strong>The basic idea is that the acquisition and release of resources are tied to the object’s creation and destruction, respectively.</strong></p>
<p><strong>Example: Managing Files</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFile</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyFile</span>(<span class="type">const</span> <span class="type">char</span>* filename) : <span class="built_in">file</span>(filename)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to open file.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;File opened.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyFile</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;File closed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::ifstream file;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Using RAII to manage file handles</span></span><br><span class="line">        <span class="function">MyFile <span class="title">myFile</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Other code...</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) </span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// Exception occurred, but MyFile destructor is still called</span></span><br><span class="line">        <span class="comment">// File handle is closed automatically</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Smart-Pointer">Smart Pointer</h2>
<h3 id="unique-ptr"><code>unique_ptr</code></h3>
<h4 id="Create">Create</h4>
<p>A <code>unique_ptr</code> holds the exclusive ownership of the memory it points to, meaning there can be no other <code>unique_ptr</code> pointing to the same memory at the same time.</p>
<p>When a <code>unique_ptr</code> goes out of scope, the memory it manages is <strong>automatically deallocated.</strong></p>
<p>To utilize <code>unique_ptr</code>, you must include the <code>&lt;memory&gt;</code> header file at the beginning of your source code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><code>unique_ptr</code> can also be created and assigned heap memory directly upon its declaration:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Directly managing a new int object</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptrObj</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">4</span>))</span></span>; </span><br></pre></td></tr></table></figure>
<p><strong><span style="color:blue"> It implies that the constructor of <code>unique_ptr</code>&gt; take a raw pointer. since <code>new int(4)</code> returns a pointer of <code>int </code>type.</span></strong></p>
<p>When the <code>unique_ptr</code> object <code>ptrObj</code> goes out of scope, it will automatically delete the memory linked with the <code>unique_ptr</code> object.</p>
<p>Initialize it with NULL pointer.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptrObj</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Later in the code</span></span><br><span class="line">ptrObj.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>()); <span class="comment">// Now managing a new int object</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Differences between <code>NULL</code> and <code>nullptr</code></p>
<p><code>NULL</code> is macro, but <code>nullptr</code> is of type <code>std::nullptr_t</code></p>
<ul>
<li><code>NULL</code> is not type-safe because it can be implicitly converted to integral types, leading to potential issues.</li>
<li><code>nullptr</code> is type-safe. It cannot be implicitly converted to integral types, reducing the chances of accidental errors.</li>
</ul>
</blockquote>
<p>You can dereference it as a row pointer.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">intPtr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">4</span>))</span></span>; </span><br><span class="line"><span class="comment">// Assigning value to the managed integer</span></span><br><span class="line">*intPtr = <span class="number">42</span>; </span><br><span class="line"><span class="comment">// Dereferencing to print the value</span></span><br><span class="line">std::cout &lt;&lt; *intPtr; </span><br></pre></td></tr></table></figure>
<p>And if you need to obtain the raw pointer for some operations, especially when interacting with APIs that require raw pointers, <code>unique_ptr</code> provides a <code>get()</code> method:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* rawIntPtr = intPtr.<span class="built_in">get</span>(); <span class="comment">// Acquires the raw pointer</span></span><br><span class="line"><span class="comment">// Remember: don&#x27;t use rawIntPtr for memory management!</span></span><br></pre></td></tr></table></figure>
<p>You also can initialize a <code>unique_ptr</code> with <code>std::make_unique&lt;DataType&gt;(Construtor args)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptrObj = std::<span class="built_in">make_unique</span>&lt;DATA_TYPE&gt;(constructor_arguments);</span><br></pre></td></tr></table></figure>
<p>Practical example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tweet</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string text; <span class="comment">// The content of the tweet</span></span><br><span class="line">    <span class="type">int</span> viewCount;    <span class="comment">// Number of times the tweet has been viewed</span></span><br><span class="line">    <span class="type">int</span> likeCount;    <span class="comment">// Number of likes on the tweet</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Constructor to initialize the tweet object with text, view count, and like count</span></span><br><span class="line">    <span class="built_in">Tweet</span>(<span class="type">const</span> std::string &amp;txt, <span class="type">int</span> views, <span class="type">int</span> likes)</span><br><span class="line">        : <span class="built_in">text</span>(txt), <span class="built_in">viewCount</span>(views), <span class="built_in">likeCount</span>(likes)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt; <span class="string">&quot;*** Tweet::Constructor ***\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Display function to print the details of the tweet</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Tweet: &quot;</span> &lt;&lt; text &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Views: &quot;</span> &lt;&lt; viewCount &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Likes: &quot;</span> &lt;&lt; likeCount &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Tweet</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt; <span class="string">&quot;*** Tweet::Destructor ***\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Wrapping the raw pointer with a unique_ptr</span></span><br><span class="line">    <span class="comment">// unique_ptr now exclusively manages the Tweet</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Tweet&gt; <span class="title">tweetPtr</span><span class="params">(<span class="keyword">new</span> Tweet(<span class="string">&quot;Good Morning&quot;</span>, <span class="number">2000</span>, <span class="number">31</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    tweetPtr-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>Resource Acquisition</strong>: The <code>Tweet</code> object is dynamically allocated with <code>new</code>, and its pointer is immediately passed to <code>tweetPtr</code>. The acquisition of the resource and its initialization with a managing entity are simultaneous.</li>
<li><strong>Resource Management</strong>: As soon as <code>unique_ptr</code> takes control, it becomes the sole manager of the <code>Tweet</code> object’s memory. The original raw pointer (<code>rawTweet</code>) is set to <code>nullptr</code> to prevent accidental deletion or access, reinforcing that <code>tweetPtr</code> now has exclusive management over the object.</li>
<li><strong>Resource Release</strong>: When <code>tweetPtr</code> goes out of scope, which would be at the end of the <code>main</code> function in this case, its destructor is automatically invoked. This destructor frees the associated heap memory, destroying the <code>Tweet</code> object. This automatic deallocation is the cornerstone of RAII—resources are cleaned up without explicit instructions from the developer.</li>
</ol>
<h4 id="Can-a-unique-pointer-be-copied">Can a unique pointer be copied?</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Attempting to copy will fail at compile time</span></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; anotherPtr = ptrObj; <span class="comment">// This will not compile</span></span><br></pre></td></tr></table></figure>
<p>Although copying a <code>unique_ptr</code> object is not allowed, but you can transfer ownership of underlying memory resource managed by a <code>unique_ptr</code> to another <code>unique_ptr</code> using the <code>std::move()</code> function.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ptr is managing a new int with value 11</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">11</span>))</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move ptr to another unique_ptr</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; anotherPtr = std::<span class="built_in">move</span>(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ptr is now empty, and anotherPtr manages the resource</span></span><br><span class="line">    <span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr is now nullptr&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(anotherPtr)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;anotherPtr points to memory with value: &quot;</span> &lt;&lt; *anotherPtr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Reset-renounce-a-unique-pointer">Reset (renounce) a unique pointer</h4>
<p>Calling the <code>reset()</code> method on a <code>unique_ptr</code> will perform two operations:</p>
<ol>
<li>It will deallocate or release the memory that the <code>unique_ptr</code> currently owns.</li>
<li>It will set the <code>unique_ptr</code> itself to point to <code>nullptr</code>, effectively indicating that it no longer manages any memory.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// uniquePtr now owns an int with value 11</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">uniquePtr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">11</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Resetting the uniquePtr</span></span><br><span class="line">    uniquePtr.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// After reset, uniquePtr no longer owns the previous int</span></span><br><span class="line">    <span class="keyword">if</span> (!uniquePtr)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;uniquePtr has been reset and is now nullptr.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Pass-a-unique-pointer-to-a-function">Pass a unique pointer to a function</h4>
<p>because unique pointers are designed to be unique, <strong>they cannot be copied</strong>; they can only be moved.</p>
<p>Suppose we have a function that accepts a unique pointer like this,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processValue</span><span class="params">(std::unique_ptr&lt;<span class="type">int</span>&gt; ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Print information about the ptr (in our case, an int value)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Integer value: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If we try to pass a unique pointer to the function,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This line would cause a compile-time error</span></span><br><span class="line"><span class="comment">// Because we can not create a copy of  unique pointer</span></span><br><span class="line"><span class="built_in">processValue</span>(ptrObj);</span><br></pre></td></tr></table></figure>
<p>Instead, we can use <code>std::move()</code>,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We can move unique_ptr object</span></span><br><span class="line"><span class="built_in">processValue</span>(std::<span class="built_in">move</span>(ptrObj)); <span class="comment">// This is correct</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Once moved, unique_ptr object is empty and internally points to null</span></span><br><span class="line"><span class="keyword">if</span> (!ptrObj)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptrObj is now null.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer value: 10</span><br><span class="line">ptrObj is now null.</span><br></pre></td></tr></table></figure>
<p><strong><span style="color:red">Once the <code>unique_ptr</code> object is moved, the memory it was holding is transferred, and then it points to <code>nullptr</code>. </span></strong></p>
<p>Also, we can use <code>std::make_unique()</code>,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We can move unique_ptr object</span></span><br><span class="line"><span class="built_in">processValue</span>(std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">30</span>)); <span class="comment">// This is correct</span></span><br></pre></td></tr></table></figure>
<h4 id="Return-unique-ptr-from-a-function-in-C">Return unique_ptr from a function in C++</h4>
<p>C++ supports <strong>Return Value Optimization</strong> (RVO) and move semantics, which means you can return a <code>unique_ptr</code> from a function without worrying about copying the pointer or the managed object.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">GetData1</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unique_ptr is moved from here</span></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">GetData2</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; uniquePtr1 = <span class="built_in">GetData1</span>(<span class="number">42</span>);</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; uniquePtr2 = <span class="built_in">GetData2</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do some work here</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Use-unique-ptr-with-Arrays">Use unique_ptr with Arrays</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> arr = std::<span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>[]&gt;(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">6</span>]&#123;<span class="number">67</span>, <span class="number">78</span>, <span class="number">16</span>, <span class="number">26</span>, <span class="number">98</span>, <span class="number">63</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the unique pointer array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++14 introduced <code>std::make_unique</code>, which provides a safer alternative to using <code>new</code> directly. Here’s how you would use it for arrays:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> arr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize elements (not directly via make_unique due to limitations)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] = (i + <span class="number">1</span>) * <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over the array elements &amp; Print them</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Important Points to Remember:</p>
<ul>
<li><strong>Array Type Indication</strong>: When using a unique pointer to manage an array, the type declaration must include <code>[]</code> to indicate that it is an array type.</li>
<li><strong>Auto Deduction</strong>: The <code>auto</code> keyword can be used for type deduction to simplify the syntax when declaring a unique pointer for an array.</li>
<li><strong>Accessing Elements</strong>: Access elements of a unique pointer array using the subscript operator <code>[]</code> just like a regular array.</li>
<li><strong>Safe Memory Management</strong>: Just like with single objects, <code>std::unique_ptr</code> for arrays ensures that the allocated memory is automatically and safely deallocated when the unique pointer goes out of scope.</li>
<li><strong>Initialization Limitations</strong>: Directly initializing array elements during allocation with <code>std::make_unique</code> isn’t supported. You must initialize elements after allocation.</li>
</ul>
<h3 id="shared-ptr"><code>shared_ptr</code></h3>
<p>Multiple <code>std::shared_ptr</code> objects can point to same dynamically allocated memory. It ensures automatic deletion of the associated memory when there are no more <code>shared_ptr</code> instances pointing to it, thereby preventing memory leaks and dangling pointers.</p>
<p><strong>Shared Ownership</strong></p>
<p>Internally, it utilizes a reference counting mechanism to keep track of how many <code>shared_ptr</code> objects are associated with the same dynamically allocated memory. Destruction of each <code>shared_ptr</code> object decrements the reference count. When the reference count reaches zero, the underlying dynamically memory gets deleted.</p>
<p><strong>Facilitate Polymorphic Behavior</strong></p>
<p>Since <strong><code>shared_ptr</code> can be used with inheritance hierarchies</strong>, it enables polymorphic behavior when handling collections of base class pointers that point to derived instances.</p>
<p><strong>Thread Safety</strong></p>
<p>The <code>shared_ptr</code> implementation in the standard library is thread-safe in terms of reference counting operations. Multiple threads can create and destroy their own shared_ptr instances pointing to the same object without additional synchronization for the reference count.</p>
<p><strong>Atomic Reference Counting:</strong></p>
<ul>
<li><code>std::shared_ptr</code> maintains a reference count to manage the lifetime of the dynamically allocated object it owns.</li>
<li>The reference count is updated atomically, which means that operations like incrementing or decrementing the count are guaranteed to be performed as a single, uninterruptible operation.</li>
</ul>
<p><strong>Thread Safety for Reference Counting:</strong></p>
<ul>
<li>Operations that involve updating the reference count are thread-safe. For example, copying or assigning <code>std::shared_ptr</code> instances across threads is safe in terms of reference counting.</li>
<li><span style="color:red">However, the actual access and modification of the managed object must be synchronized separately if needed.</span></li>
</ul>
<p><strong>When Not to Use <code>shared_ptr</code></strong></p>
<p>Despite its benefits, <code>shared_ptr</code> is not always the best choice. These are the scenarios, when we should avoid <code>shared_ptr</code> Smart Pointer,</p>
<ul>
<li><strong>Overhead</strong>: The control block that manages the reference count has a performance and memory overhead.</li>
<li><strong>Cycles</strong>: <code>shared_ptr</code> can lead to memory leaks if there are cycles of references. This problem can be mitigated by using <code>weak_ptr</code>.</li>
</ul>
<h4 id="Create-2">Create</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>())</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>For the integer</strong>: The memory needed to store the actual integer.</li>
<li><strong>For the reference count</strong>: The control block that contains the reference count and any other control data needed to manage shared ownership. Initially, <strong>this count will be 1.</strong></li>
</ol>
<h4 id="How-shared-ptr-works">How <code>shared_ptr</code> works?</h4>
<ul>
<li><strong>Acquisition:</strong> When a new <code>shared_ptr</code> is created and points to an object, the reference count associated with that object is increased by one.</li>
<li><strong>Copy or Assignment:</strong> When a <code>shared_ptr</code> is copied or assigned, the reference count will again increase since another smart pointer now points to the same object.</li>
<li><strong>Destruction:</strong> When a <code>shared_ptr</code> goes out of scope or is reset, it decreases the reference count of its associated object by one.</li>
<li><strong>Deletion:</strong> If the reference count becomes zero, which means no <code>shared_ptr</code> objects are pointing to the object, the allocated memory is deallocated using the <code>delete</code> operator.</li>
</ul>
<h4 id="How-to-Check-Reference-Count-of-a-shared-ptr-Object">How to Check Reference Count of a <code>shared_ptr</code> Object</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the number of shared_ptr objects managing the same raw pointer</span></span><br><span class="line"><span class="keyword">auto</span> count = p1.<span class="built_in">use_count</span>(); </span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;memory&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>())</span></span>;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; p2 = p1;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reference Count: &quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt;  <span class="string">&quot;Reference Count: &quot;</span> &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Reference Count: 2</span><br><span class="line">Reference Count: 2</span><br></pre></td></tr></table></figure>
<p>Once the destructor of a shared pointer was invoked, the reference count for the allocated memory decrements by one. The allocated memory will not be released until the reference count associated with it becomes zero.</p>
<h4 id="Using-std-make-shared-for-creating">Using std::make_shared for creating</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This will cause a compile-time error</span></span><br><span class="line"><span class="comment">// Error: Cannot convert &#x27;int*&#x27; to &#x27;std::shared_ptr&lt;int&gt;&#x27; in assignment</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p1 = <span class="keyword">new</span> <span class="built_in">int</span>();</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();</span><br></pre></td></tr></table></figure>
<p><code>std::make_shared</code> performs a single memory allocation for both the object and the control block used for reference counting, making it more efficient than using <code>new</code> separately.</p>
<h4 id="Detaching-the-Associated-Raw-Pointer-from-shared-ptr">Detaching the Associated Raw Pointer from <code>shared_ptr</code></h4>
<p>To make a <code>shared_ptr</code> relinquish control of its managed object, you can use the <code>reset()</code> method.</p>
<p><strong><code>reset()</code> Function Without Parameter:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">p1.<span class="built_in">reset</span>();</span><br></pre></td></tr></table></figure>
<p>This decreases its reference count by 1, and if the reference count becomes 0, it deletes the managed object, basically it will delete the dynamically allocated object.</p>
<p><span style="color:red">Note: <strong>even if there are other <code>std::shared_ptr</code> instances pointing to the same dynamically allocated memory, when one of them calls the <code>reset</code> method and the reference count becomes zero, the associated memory will be released.</strong> </span></p>
<p><strong><code>reset()</code> Function With Parameter:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">34</span>));</span><br></pre></td></tr></table></figure>
<p>In this case, the <code>shared_ptr</code> will manage a new pointer, and its reference count will become 1.</p>
<p><strong>Resetting Using <code>nullptr</code>:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1 = <span class="literal">nullptr</span>; <span class="comment">// Equivalent to p1.reset();</span></span><br></pre></td></tr></table></figure>
<p>Setting the <code>shared_ptr</code> to <code>nullptr</code> will decrease the reference count and delete the managed object if the count reaches zero.</p>
<h4 id="Dereferencing-a-shared-ptr">Dereferencing a <code>shared_ptr</code></h4>
<p>You can dereference a <code>shared_ptr</code> using the unary <code>*</code> operator to access the object it points to</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getText</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Some Random Text!! \n&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Message&gt; msgPtr = std::<span class="built_in">make_shared</span>&lt;Message&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dereference the shared_ptr to call a function on the Message object</span></span><br><span class="line">    (*msgPtr).<span class="built_in">getText</span>();</span><br><span class="line">    <span class="comment">// or equivalently</span></span><br><span class="line">    msgPtr-&gt;<span class="built_in">getText</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>-&gt;</code> operator allows you to directly access members (methods or variables) of the object that the <code>shared_ptr</code> points to.</p>
<h4 id="Comparison-Operations-with-shared-ptr">Comparison Operations with shared_ptr</h4>
<p><code>shared_ptr</code> instances can be compared with other <code>shared_ptr</code> instances, or with <code>nullptr</code>, to determine equality (<code>==</code>) or inequality (<code>!=</code>). Two <code>shared_ptr</code> instances are equal if they point to the same object or if both are null.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;Message&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;Message&gt;();</span><br><span class="line">std::shared_ptr&lt;Message&gt; ptr2 = ptr1; <span class="comment">// ptr2 now shares ownership with ptr1</span></span><br><span class="line">std::shared_ptr&lt;Message&gt; ptr3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptr1 == ptr2) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr1 and ptr2 point to the same object.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptr3 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr3 is uninitialized and holds no object.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Complete-Example-of-shared-ptr">Complete Example of <code>shared_ptr</code></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// We need to include this for shared_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Creating a shared_ptr through make_shared</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; p1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    *p1 = <span class="number">78</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p1 = &quot;</span> &lt;&lt; *p1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shows the reference count</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p1 Reference count = &quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Second shared_ptr object will also point to same pointer internally</span></span><br><span class="line">    <span class="comment">// It will make the reference count to 2.</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shows the reference count</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p2 Reference count = &quot;</span> &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p1 Reference count = &quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Comparing smart pointers</span></span><br><span class="line">    <span class="keyword">if</span> (p1 == p2)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;p1 and p2 are pointing to same pointer\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reset p1 &quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset the shared_ptr, in this case it will not point to any Pointer internally</span></span><br><span class="line">    <span class="comment">// hence its reference count will become 0.</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p1 Reference Count = &quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset the shared_ptr, in this case it will point to a new Pointer internally</span></span><br><span class="line">    <span class="comment">// hence its reference count will become 1.</span></span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">11</span>));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p1  Reference Count = &quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assigning nullptr will de-attach the associated pointer and make it to point null</span></span><br><span class="line">    p1 = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p1  Reference Count = &quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p1)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;p1 is NULL&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p1 = 78</span><br><span class="line">p1 Reference count = 1</span><br><span class="line">p2 Reference count = 2</span><br><span class="line">p1 Reference count = 2</span><br><span class="line">p1 and p2 are pointing to same pointer</span><br><span class="line">Reset p1 </span><br><span class="line">p1 Reference Count = 0</span><br><span class="line">p1  Reference Count = 1</span><br><span class="line">p1  Reference Count = 0</span><br><span class="line">p1 is NULL</span><br></pre></td></tr></table></figure>
<h4 id="Using-shared-ptr-with-Arrays-in-C">Using <code>shared_ptr</code> with Arrays in C++</h4>
<p>By default, a <code>shared_ptr</code> calls the <code>delete</code> operator to deallocate the memory, like so:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pointer;</span><br></pre></td></tr></table></figure>
<p>Here is an incorrect example where <code>shared_ptr</code> is used with a raw array:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">12</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>In this scenario, when <code>p3</code> goes out of scope, the <code>shared_ptr</code> will try to delete the array using the <code>delete</code> operator. However, this is incorrect because the <code>delete</code> operator is intended for single objects, not arrays.</p>
<p>To correctly manage an array with a <code>shared_ptr</code>, you should provide a custom deleter that uses <code>delete[]</code>, like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">12</span>], std::default_delete&lt;<span class="type">int</span>[]&gt;())</span></span>;</span><br></pre></td></tr></table></figure>
<p>Alternatively, for arrays, you can use <code>std::unique_ptr</code> with a special array form, which handles arrays correctly:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">p4</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">12</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>It’s important to note that since C++17, we can use <code>std::make_shared</code> and <code>std::make_unique</code> for arrays as well, which provide a safer and more convenient way of handling dynamic arrays:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For shared_ptr with arrays (C++17 and later)</span></span><br><span class="line"><span class="keyword">auto</span> p5 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>[]&gt;(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// For unique_ptr with arrays</span></span><br><span class="line"><span class="keyword">auto</span> p6 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(<span class="number">12</span>);</span><br></pre></td></tr></table></figure>
<p>Using <code>std::make_shared</code> and <code>std::make_unique</code> also avoids the need to specify a custom deleter, as they correctly deduce the array type and use the appropriate deletion mechanism.</p>
<h4 id="Using-a-Normal-Function-as-Custom-Deleter-in-shared-ptr">Using a Normal Function as Custom Deleter in <code>shared_ptr</code></h4>
<p>The <code>deleter</code> function is a custom deleter function that we want to use instead of the default <code>delete</code> operator to destroy an array.</p>
<p>Adding a custom deleter to a <code>shared_ptr</code> is a flexible way to control the destruction of the managed object when the last <code>shared_ptr</code> owning it goes out of scope.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sample</span> &#123;</span><br><span class="line">    <span class="built_in">Sample</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Sample CONSTRUCTOR\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Sample</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Sample DESTRUCTOR\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function that calls &#x27;delete[]&#x27; on the received pointer</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleter</span><span class="params">(Sample* x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Custom DELETER FUNCTION CALLED\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Creating a shared_ptr with custom deleter</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;Sample&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> Sample[<span class="number">3</span>], deleter)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ouput:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sample CONSTRUCTOR</span><br><span class="line">Sample CONSTRUCTOR</span><br><span class="line">Sample CONSTRUCTOR</span><br><span class="line">Custom DELETER FUNCTION CALLED</span><br><span class="line">Sample DESTRUCTOR</span><br><span class="line">Sample DESTRUCTOR</span><br><span class="line">Sample DESTRUCTOR</span><br></pre></td></tr></table></figure>
<p>Also, it’s worth noting that while this method of managing arrays works well, it’s generally recommended to use <code>std::vector</code> or <code>std::array</code> for array management unless there’s a specific need for dynamic array allocation with raw pointers. These standard library containers handle memory management automatically and safely.</p>
<h4 id="Using-a-Lambda-Function-as-Custom-Deleter-in-shared-ptr">Using a Lambda Function as Custom Deleter in <code>shared_ptr</code></h4>
<p>As a custom deleter we can either use a function object or a lambda function, as demonstrated in the below example,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Sample</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Sample CONSTRUCTOR\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Sample</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Sample DESTRUCTOR\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Creating a shared_ptr with a lambda function as the custom deleter</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;Sample&gt; <span class="title">p4</span><span class="params">( <span class="keyword">new</span> Sample[<span class="number">12</span>],</span></span></span><br><span class="line"><span class="params"><span class="function">                                [](Sample *x) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                                    std::cout &lt;&lt; <span class="string">&quot;Lambda Function DELETER CALLED\n&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">delete</span>[] x; </span></span></span><br><span class="line"><span class="params"><span class="function">                                &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No need to manually delete; it&#x27;s handled by the custom deleters</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Smart-Pointer-vs-Raw-Pointer-in-C">Smart Pointer vs Raw Pointer in C++</h4>
<p><strong>Missing ++, – – and [] operators in <code>shared_ptr</code></strong></p>
<p>While <code>shared_ptr</code> in C++ offers robust memory management and facilitates collaborative ownership of resources, it intentionally lacks some operators that are available to raw pointers. This is primarily to prevent operations that could potentially compromise resource management or lead to undefined behavior.</p>
<p>If you want to access an array pointed to by a shared pointer, do likewise</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Creating a shared pointer to an array of integers</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sharedArrayPtr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, std::default_delete&lt;<span class="type">int</span>[]&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Accessing the array through the shared pointer</span></span><br><span class="line">    <span class="type">int</span>* rawArrayPtr = sharedArrayPtr.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using array indexing to access elements</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; rawArrayPtr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Alternatively, using pointer arithmetic</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; *(rawArrayPtr + i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Get-the-corresponding-raw-pointer">Get the corresponding raw pointer</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;Sample&gt; ptr = std::<span class="built_in">make_shared</span>&lt;Sample&gt;();</span><br><span class="line"></span><br><span class="line">Sample* rawPtr = ptr.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>
<h4 id="How-not-to-use-Smart-Pointers-in-C">How not to use Smart Pointers in C++?</h4>
<p><strong>Avoiding creating multiple <code>shared_ptr</code> with same Raw Pointer</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* rawPtr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(rawPtr)</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(rawPtr)</span></span>;  <span class="comment">// Problematic!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// When ptr2 goes out of scope, it will delete rawPtr.</span></span><br><span class="line">    <span class="comment">// Then ptr1 will be left with a dangling pointer.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>rawPtr</code> is a raw pointer that points to an integer allocated on the heap.</li>
<li><code>ptr1</code> is a shared pointer that takes ownership of the integer.</li>
<li><code>ptr2</code> is another shared pointer incorrectly given ownership of the same integer.</li>
<li>When <code>ptr2</code> goes out of scope, it deletes the integer. <code>ptr1</code> is now a dangling pointer.</li>
<li>When <code>ptr1</code> goes out of scope, it will try to delete the already deleted integer, leading to a crash.</li>
</ol>
<p><strong>Avoiding Creating Smart Pointers with Stack memory</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">12</span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(&amp;x)</span></span>;  <span class="comment">// Problematic!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ptr will try to delete memory it does not own when going out of scope.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>x</code> is a stack-allocated integer.</li>
<li><code>ptr</code> is a shared pointer that incorrectly attempts to take ownership of <code>x</code>.</li>
<li>When <code>ptr</code> goes out of scope, it will call <code>delete</code> on a stack-allocated variable, causing a crash.</li>
</ol>
<h4 id="Recommended-Practices-for-Smart-Pointers-in-C">Recommended Practices for Smart Pointers in C++</h4>
<p>To avoid these issues, it is recommended to use <code>std::make_shared</code>. This function template enables the creation of <code>std::shared_ptr</code> objects <strong>without directly passing raw pointers</strong>, ensuring safe memory allocation and deallocation.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>; <span class="comment">// Copy of ptr1, shares ownership.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Both ptr1 and ptr2 co-own the memory safely.</span></span><br><span class="line">    <span class="comment">// Memory will be automatically deleted when the last shared_ptr is destroyed.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Advantages of make_shared</strong></p>
<ul>
<li>It creates a <code>shared_ptr</code> in a safe manner, ensuring there is only one owner for the newly allocated memory.</li>
<li>It is more efficient because it performs a single heap allocation for the object and the control block used by the <code>shared_ptr</code>.</li>
<li>It prevents the creation of shared pointers to stack memory because <code>make_shared</code> always allocates memory on the heap.</li>
</ul>
<h3 id="weak-ptr"><code>weak_ptr</code></h3>
<p>Misusing <code>shared_ptr</code> can lead to issues like memory leaks, especially in complex data structures such as binary trees. Let’s explore the proper use of <code>shared_ptr</code> and how <code>weak_ptr</code> can help resolve certain problems.</p>
<h4 id="Case-Study-1-Creating-Binary-Tree-with-shared-ptr">Case Study 1: Creating Binary Tree with <code>shared_ptr</code></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;Node&gt; leftPtr;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; rightPtr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Node</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; root = std::<span class="built_in">make_shared</span>&lt;Node&gt;(<span class="number">4</span>);</span><br><span class="line">    root-&gt;leftPtr = std::<span class="built_in">make_shared</span>&lt;Node&gt;(<span class="number">2</span>);</span><br><span class="line">    root-&gt;rightPtr = std::<span class="built_in">make_shared</span>&lt;Node&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Constructor</span><br><span class="line">Constructor</span><br><span class="line">Constructor</span><br><span class="line">Destructor</span><br><span class="line">Destructor</span><br><span class="line">Destructor</span><br></pre></td></tr></table></figure>
<p>Here, the constructors and destructors are called correctly, ensuring that memory is properly managed and released.</p>
<h4 id="Problem-Introducing-Parent-Pointers"><strong>Problem: Introducing Parent Pointers</strong></h4>
<p>When we add a parent pointer to each child:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;Node&gt; leftPtr;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; rightPtr;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; parentPtr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Node</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; ptr = std::<span class="built_in">make_shared</span>&lt;Node&gt;(<span class="number">4</span>);</span><br><span class="line">    ptr-&gt;leftPtr = std::<span class="built_in">make_shared</span>&lt;Node&gt;(<span class="number">2</span>);</span><br><span class="line">    ptr-&gt;leftPtr-&gt;parentPtr = ptr;</span><br><span class="line">    ptr-&gt;rightPtr = std::<span class="built_in">make_shared</span>&lt;Node&gt;(<span class="number">5</span>);</span><br><span class="line">    ptr-&gt;rightPtr-&gt;parentPtr = ptr;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr reference count = &quot;</span> &lt;&lt; ptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr-&gt;leftPtr reference count = &quot;</span> &lt;&lt; ptr-&gt;leftPtr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr-&gt;rightPtr reference count = &quot;</span> &lt;&lt; ptr-&gt;rightPtr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Constructor</span><br><span class="line">Constructor</span><br><span class="line">Constructor</span><br><span class="line">ptr reference count = 3</span><br><span class="line">ptr-&gt;leftPtr reference count = 1</span><br><span class="line">ptr-&gt;rightPtr reference count = 1</span><br></pre></td></tr></table></figure>
<p>Now the constructor will be called three times, but there will be no call to the destructor, and that indicates a memory leak.</p>
<p>The reason for this problem with <code>shared_ptr</code> is cyclic references, i.e.,</p>
<p>If two objects refer to each other using <code>shared_ptr</code>s, then no one will delete the internal memory when they go out of scope.</p>
<p>When the <code>main</code> function returns, <code>ptr</code> goes out of scope (since it is allocated on stack), triggering its destructor. However, there are still two pointers (<code>leftPtr</code> and <code>rightPtr</code> of root node) pointing to the node managed by <code>ptr</code>. As a result, the memory for the node will not be deallocated. The memory for the left child and right child will be deallocated only when <code>leftPtr</code> and <code>rightPtr</code> inside the root node go out of scope, which is when the root node is released. Unfortunately, this scenario never occurs due to cyclic references.</p>
<h4 id="Case-Study-2-Linked-List">Case Study 2: Linked List</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout, std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;Node&gt; next;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> value) : <span class="built_in">val</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Node</span>(<span class="type">void</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; node_1 = std::<span class="built_in">make_shared</span>&lt;Node&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">auto</span> node_2 = std::<span class="built_in">make_shared</span>&lt;Node&gt;(<span class="number">200</span>);</span><br><span class="line">    node_1-&gt;next = node_2;</span><br><span class="line">    node_2-&gt;next = node_1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;node_1 count: &quot;</span> &lt;&lt; node_1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;node_2 count: &quot;</span> &lt;&lt; node_2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Solution-Using-weak-ptr-Smart-Pointer">Solution: Using weak_ptr Smart Pointer</h4>
<p>To solve the cyclic reference problem, we can replace the <code>shared_ptr</code> for the parent pointer with a <code>weak_ptr</code>. This allows us to share but not own the object, breaking the cycle:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::weak_ptr&lt;Node&gt; parentPtr;</span><br></pre></td></tr></table></figure>
<p><span style="color:orange"><strong>A <code>weak_ptr</code> doesn’t contribute to the reference count, hence it avoids creating strong reference cycles.</strong></span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>);</span><br><span class="line"><span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">weakPtr</span><span class="params">(ptr)</span></span>;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr_2 = weakPtr.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptr_2) </span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; (*ptr_2) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reference Count :: &quot;</span> &lt;&lt; ptr_2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (weakPtr.<span class="built_in">expired</span>() == <span class="literal">false</span>) </span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Not expired yet&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>lock</code> function checks if the <code>std::weak_ptr</code> is still valid (nonempty) and if so, creates a <code>std::shared_ptr</code> pointing to the same object.</p>
<h4 id="Improved-Binary-Tree-Example">Improved Binary Tree Example</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;Node&gt; leftPtr;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; rightPtr;</span><br><span class="line">    std::weak_ptr&lt;Node&gt; parentPtr; <span class="comment">// Changed from shared_ptr to weak_ptr</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Node</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; root = std::<span class="built_in">make_shared</span>&lt;Node&gt;(<span class="number">4</span>);</span><br><span class="line">    root-&gt;leftPtr = std::<span class="built_in">make_shared</span>&lt;Node&gt;(<span class="number">2</span>);</span><br><span class="line">    root-&gt;leftPtr-&gt;parentPtr = root;</span><br><span class="line">    root-&gt;rightPtr = std::<span class="built_in">make_shared</span>&lt;Node&gt;(<span class="number">5</span>);</span><br><span class="line">    root-&gt;rightPtr-&gt;parentPtr = root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Outputs to help visualize reference counts</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;root reference count = &quot;</span> &lt;&lt; root.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;root-&gt;leftPtr reference count = &quot;</span> &lt;&lt; root-&gt;leftPtr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;root-&gt;rightPtr reference count = &quot;</span> &lt;&lt; root-&gt;rightPtr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;root-&gt;rightPtr-&gt;parentPtr reference count (via lock) = &quot;</span> &lt;&lt; root-&gt;rightPtr-&gt;parentPtr.<span class="built_in">lock</span>().<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;root-&gt;leftPtr-&gt;parentPtr reference count (via lock) = &quot;</span> &lt;&lt; root-&gt;leftPtr-&gt;parentPtr.<span class="built_in">lock</span>().<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><span style="color:red">Note: <code>root-&gt;rightPtr-&gt;parentPtr.lock().use_count()</code> creates an anonymous, then calls the method <code>use_count()</code>, thus there are two shared pointers pointing to the associated memory. </span></strong></p>
<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Constructor</span><br><span class="line">Constructor</span><br><span class="line">Constructor</span><br><span class="line">root reference count = 1</span><br><span class="line">root-&gt;leftPtr reference count = 1</span><br><span class="line">root-&gt;rightPtr reference count = 1</span><br><span class="line">root-&gt;rightPtr-&gt;parentPtr reference count (via lock) = 2</span><br><span class="line">root-&gt;leftPtr-&gt;parentPtr reference count (via lock) = 2</span><br><span class="line">Destructor</span><br><span class="line">Destructor</span><br><span class="line">Destructor</span><br></pre></td></tr></table></figure>
<h2 id="Rvalue-Reference-Move-Constructor">Rvalue Reference &amp; Move Constructor</h2>
<p>Rvalue references are designed to provide us with the opportunity to perform move semantics, which allows you us efficiently transfer ownership of resources from one object to another without unnecessary copying.</p>
<blockquote>
<p><strong>Lvalue (Left Value):</strong> <strong>anything whose address is accessible. It means we can take address of lvalue using <code>&amp;</code> operator.</strong></p>
<ul>
<li>An lvalue refers to an object or a memory location that has a name, i.e., it <span style="color:red"><strong>has an identifiable location in memory.</strong></span></li>
<li>Lvalues represent objects that can potentially be modified.</li>
<li>Examples of lvalues include variables, array elements, and dereferenced pointers.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">int</span> x = <span class="number">42</span>;  <span class="comment">// &#x27;x&#x27; is an lvalue</span></span><br><span class="line">&gt;<span class="type">int</span>* ptr = &amp;x;  <span class="comment">// Dereferenced pointer is an lvalue</span></span><br><span class="line">&gt;<span class="type">int</span> z = x + <span class="number">1</span>; <span class="comment">// x + 1 is an RVALUE</span></span><br></pre></td></tr></table></figure>
<p><span style="color:orange"><strong>Noete: We can not take  the address of  <code>x + 1</code>, thus <code>x + 1</code> is an rvalue, since the result may be storoed in a register.</strong></span></p>
<p><strong>Rvalue (Right Value):</strong> <strong>anything that is not an lvalue.</strong></p>
<ul>
<li>An rvalue refers to a temporary or a value that <span style="color:red"><strong>doesn’t necessarily have a name or an identifiable memory location.</strong></span></li>
<li>Rvalues often represent <span style="color:blue"><strong>temporary results or constants</strong></span>.</li>
<li>Rvalues are typically used on the right side of an assignment.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">int</span> y = <span class="number">5</span>;  <span class="comment">// &#x27;5&#x27; is an rvalue</span></span><br><span class="line">&gt;<span class="type">int</span> sum = x + y;  <span class="comment">// &#x27;x + y&#x27; is an rvalue (temporary result)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>Recall lvalue reference:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;refX = x;</span><br></pre></td></tr></table></figure>
<p>A lvalue reference can not point to a rvalue,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;lvalueRef = (x + <span class="number">1</span>); <span class="comment">// COMPILE Error - lvalue Reference Can&#x27;t point to rvalue</span></span><br></pre></td></tr></table></figure>
<p><strong>rvalue Reference</strong></p>
<p>Rvalue references were introduced in C++11, and they allow operations that lvalue references cannot perform.</p>
<h3 id="Declaring-rvalue-reference">Declaring rvalue reference</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp; rvalueRef = (x+<span class="number">1</span>); <span class="comment">// rvalueRef is rvalue reference</span></span><br></pre></td></tr></table></figure>
<p>Let’s see an another example,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="number">10</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;lvalueRef3 = <span class="built_in">getData</span>(); <span class="comment">// Compile error - lvalue Reference Can&#x27;t point to rvalue</span></span><br></pre></td></tr></table></figure>
<p>Although const lvalue reference can refer to temporary object returned by getData() but as its a const reference, so we can not modify this temporary.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> &amp; lvalueRef3 = <span class="built_in">getData</span>(); <span class="comment">// OK but its const</span></span><br></pre></td></tr></table></figure>
<p>But a rvalue reference can refer to rvalue without const i.e.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp; rvalueRef2 = <span class="built_in">getData</span>();</span><br></pre></td></tr></table></figure>
<h3 id="Problem-of-Temporary-Objects">Problem of Temporary Objects</h3>
<p>The Idea behind this move semantics is to reduce the load of these temporary objects in memory. Every time we return a object from a function, a temporary object is created, which eventually get copied.</p>
<p>Let us consider the following example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> * m_Data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Container</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Allocate an array of 20 int on heap</span></span><br><span class="line">        m_Data = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor: Allocation 20 int&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Container</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Data) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_Data;</span><br><span class="line">            m_Data = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Container</span>(<span class="type">const</span> Container &amp; obj) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Allocate an array of 20 int on heap</span></span><br><span class="line">        m_Data = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Copy the data from passed object</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">            m_Data[i] = obj.m_Data[i];</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy Constructor: Allocation 20 int&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>When we create an object of Container class, then its default constructor internally allocates an array of 20 <code>int</code> on heap and assign it to its member variable.</p>
<p>Similarly, Container class’s copy constructor allocates an array of 20 <code>int</code> on heap, then copy the contents of passed objects array into it and then assign it to its member variable.</p>
<p>Let’s create a simple function that creates an object of Class Container and returns it,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create am object of Container and return</span></span><br><span class="line"><span class="function">Container <span class="title">getContainer</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Container obj;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create a vector of Container Type</span></span><br><span class="line">    std::vector&lt;Container&gt; vecOfContainers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Add object returned by function into the vector</span></span><br><span class="line">    vecOfContainers.<span class="built_in">push_back</span>(<span class="built_in">getContainer</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="color:blue"><strong>We actually created two <code>Container</code> instances. The first one of them is created in <code>getContainer()</code>, the other is created (or copied) while being passed to <code>push_back()</code> mothod.</strong> </span> What a waste they are, since we allocated memory on heap twice.</p>
<h3 id="Solving-Problem-of-Temporary-Objects">Solving Problem of Temporary Objects</h3>
<p><strong>The <code>getContainer()</code> function here is a rvalue</strong>, so it can be referred by an rvalue reference. Also, using rvalue reference we can also overload functions. This time, we will overload the Constructor of class Container and this new Constructor is called <strong>move constructor</strong>.</p>
<p><strong>Move constructor takes a rvalue reference as an argument</strong> and that makes it overloaded because Copy Constructor takes the const lvalue reference as an argument.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Container</span>(Container &amp;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Just copy the pointer</span></span><br><span class="line">    m_Data = obj.m_Data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the passed object&#x27;s member to NULL</span></span><br><span class="line">    obj.m_Data = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Move Constructor&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We didn’t allocated any memory on heap in move constructor, we just shifted the control of memory.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="type">int</span> * m_Data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Container</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Allocate an array of 20 int on heap</span></span><br><span class="line">        m_Data = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor: Allocation 20 int&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Container</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Data) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_Data;</span><br><span class="line">            m_Data = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Copy Constructor</span></span><br><span class="line">    <span class="built_in">Container</span>(<span class="type">const</span> Container &amp; obj) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Allocate an array of 20 int on heap</span></span><br><span class="line">        m_Data = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Copy the data from passed object</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">            m_Data[i] = obj.m_Data[i];</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy Constructor: Allocation 20 int&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Assignment Operator</span></span><br><span class="line">    Container &amp; <span class="keyword">operator</span>=(<span class="type">const</span> Container &amp; obj) </span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;obj)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Allocate an array of 20 int on heap</span></span><br><span class="line">            m_Data = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Copy the data from passed object</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">                m_Data[i] = obj.m_Data[i];</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Assigment Operator: Allocation 20 int&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move Constructor</span></span><br><span class="line">    <span class="built_in">Container</span>(Container &amp;&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Just copy the pointer</span></span><br><span class="line">        m_Data = obj.m_Data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the passed object&#x27;s member to NULL</span></span><br><span class="line">        obj.m_Data = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Move Constructor&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move Assignment Operator</span></span><br><span class="line">    Container&amp; <span class="keyword">operator</span>=(Container &amp;&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;obj)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Just copy the pointer</span></span><br><span class="line">            m_Data = obj.m_Data;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set the passed object&#x27;s member to NULL</span></span><br><span class="line">            obj.m_Data = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;Move Assignment Operator&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create am object of Container and return</span></span><br><span class="line"><span class="function">Container <span class="title">getContainer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Container obj;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create a vector of Container Type</span></span><br><span class="line">    std::vector&lt;Container&gt; vecOfContainers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Add object returned by function into the vector</span></span><br><span class="line">    vecOfContainers.<span class="built_in">push_back</span>(<span class="built_in">getContainer</span>());</span><br><span class="line"></span><br><span class="line">    Container obj;</span><br><span class="line">    obj = <span class="built_in">getContainer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Constructor: Allocation 20 int</span><br><span class="line">Move Constructor</span><br><span class="line">Constructor: Allocation 20 int</span><br><span class="line">Constructor: Allocation 20 int</span><br><span class="line">Move Assignment Operator</span><br></pre></td></tr></table></figure>
<h3 id="Is-rvalue-immutable-in-C">Is rvalue immutable in C++?</h3>
<p><strong>Rvalues of built-in data type is Immutable</strong>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x+<span class="number">7</span>) = <span class="number">7</span>; <span class="comment">// Compile error - Can not Modify rvalue</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; <span class="type">int</span> x = <span class="number">100</span>; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="built_in">getData</span>() = <span class="number">20</span>; <span class="comment">// Compile error - Can not Modify rvalue</span></span><br></pre></td></tr></table></figure>
<p><strong>Rvalue of User Defined data type is not Immutable</strong>, <strong>but it can be modified in the same expression using its own member functions only.</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mAge;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        mAge = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">incrementAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mAge = mAge + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Define a function return a Person instance.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">getPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Person</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note: <code>getPerson()</code> is an rvalue.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person *personPtr = &amp;<span class="built_in">getPerson</span>(); <span class="comment">// COMPILE ERROR</span></span><br></pre></td></tr></table></figure>
<p>But we can modify this rvalue because it is of User Defined Data type (of Person class) i.e.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getPerson</span>().<span class="built_in">incrementAge</span>(); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<h2 id="Concurrency-in-C">Concurrency in C++</h2>
<p>Compile a multithread <code>C++</code> source file,</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ --std=c++11 -pthread -o program program.cpp</span></span><br></pre></td></tr></table></figure>
<h3 id="Thread-Creation-in-C-11">Thread Creation in C++11</h3>
<p>Every C++ application has one default main thread, which is the <code>main()</code> function. With C++11, we can create additional threads by instantiating objects of the <code>std::thread</code> class. Each <code>std::thread</code> object can be associated with a separate thread.</p>
<p><strong>Required Header</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><strong><code>std::thread</code> Constructor in C++11</strong></p>
<p>The <code>std::thread</code> constructor in C++11 allows for the association of a callback with the thread object. This callback is then executed upon the start of the new thread. The valid callbacks include:</p>
<ol>
<li><strong>Normal Function</strong></li>
<li><strong>Function Objects (Functors)</strong></li>
<li><strong>Lambda Functions</strong></li>
</ol>
<p>You can create a thread object as follows:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">thObj</span><span class="params">(&lt;CALLBACK&gt;)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>Once the thread object is instantiated, the new thread begins execution immediately</strong>, running the provided callback in parallel to the thread that initiated it. Furthermore, one thread can opt to wait for another to finish by invoking the <code>join()</code> method on the latter’s thread object.</p>
<h4 id="Creating-a-thread-using-Normal-Function">Creating a thread using Normal Function</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;thread function Executing&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now, if we want to execute this function as a separate thread from the main thread, we will create a thread object and pass this function as a parameter into the constructor.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a Thread object</span></span><br><span class="line"><span class="function">std::thread <span class="title">threadObj</span><span class="params">(thread_function)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Alternatively, if you don’t want to wait for the thread and just want to continue, you can call the <code>detach()</code> function.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A function that will ptint a line on console 5 times</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;thread function Executing&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create a Thread object</span></span><br><span class="line">    <span class="function">std::thread <span class="title">threadObj</span><span class="params">(thread_function)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Display From MainThread&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for the thread to finish</span></span><br><span class="line">    threadObj.<span class="built_in">join</span>();</span><br><span class="line">	<span class="comment">// threadObj.detach();</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Exit of Main function&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Creating-a-thread-using-Function-Objects">Creating a thread using Function Objects</h4>
<blockquote>
<p>A functor is an object that can be treated as if it were a function or function pointer. Functors are instances of classes or structures that overload the function call operator <code>operator()</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyFunctor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;From MyFunctor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>When you want to interpret <code>MyFunctor</code> as a function rather than an object,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">MyFunctor</span>()) <span class="comment">// a function</span></span><br><span class="line"><span class="built_in">MyFunctor</span>()   <span class="comment">// a class</span></span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyFunctor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from MyFunctor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">threadObj</span><span class="params">((MyFunctor))</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="Creating-a-thread-using-Lambda-functions">Creating a thread using Lambda functions</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">threadObj</span><span class="params">([](<span class="type">void</span>) -&gt; <span class="type">void</span> &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;Hello from lambda function&quot;</span> &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="Differentiating-between-threads-using-Thread-ID">Differentiating between threads using Thread ID</h4>
<p>Every thread in C++ has an associated unique ID. This ID can be fetched using the <code>get_id()</code> member function provided by the <code>std::thread</code> class. If you’re inside a function executed by a thread and wish to retrieve its ID, you can invoke <code>std::this_thread::get_id()</code>. This will return the ID of the currently executing thread.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::thread::<span class="built_in">get_id</span>()</span><br></pre></td></tr></table></figure>
<p>To get the identifier for the current thread use,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::this_thread::<span class="built_in">get_id</span>()</span><br></pre></td></tr></table></figure>
<p>However, if <code>get_id()</code> is called on a thread object that hasn’t started any thread execution (or has already finished its operation), it will return a default-constructed <code>std::thread::id</code> object. The ID returned by <code>get_id()</code> is of type <code>std::thread::id</code> and can be used for comparison operations or printed to the console.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Inside Thread :: ID  = &quot;</span>&lt;&lt;std::this_thread::<span class="built_in">get_id</span>()&lt;&lt;std::endl;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create two thread objects</span></span><br><span class="line">    <span class="function">std::thread <span class="title">threadObj1</span><span class="params">(thread_function)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">threadObj2</span><span class="params">(thread_function)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compare the Tead Id of two threads</span></span><br><span class="line">    <span class="keyword">if</span>(threadObj1.<span class="built_in">get_id</span>() != threadObj2.<span class="built_in">get_id</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Both Threads have different IDs&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;From Main Thread :: ID of Thread 1 = &quot;</span>&lt;&lt;threadObj1.<span class="built_in">get_id</span>()&lt;&lt;std::endl;    </span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;From Main Thread :: ID of Thread 2 = &quot;</span>&lt;&lt;threadObj2.<span class="built_in">get_id</span>()&lt;&lt;std::endl;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for both the thread to finish</span></span><br><span class="line">    threadObj1.<span class="built_in">join</span>();    </span><br><span class="line">    threadObj2.<span class="built_in">join</span>();    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Both Threads have different IDs</span><br><span class="line">From Main Thread :: ID of Thread 1 = 139743744489024</span><br><span class="line">From Main Thread :: ID of Thread 2 = 139743736096320</span><br><span class="line">Inside Thread :: ID  = 139743736096320</span><br><span class="line">Inside Thread :: ID  = 139743744489024</span><br></pre></td></tr></table></figure>
<h3 id="Join-Detach-Threads">Join &amp; Detach Threads</h3>
<h4 id="Join">Join</h4>
<blockquote>
<p>Why do we have to wait for other threads in the main thread?</p>
<ol>
<li><strong>Premature Termination of the Program:</strong>
<ul>
<li>If the main thread finishes execution before the child thread, and the child thread is still running, the program may terminate abruptly. This can result in the termination of the entire process, including any threads that are still executing.</li>
</ul>
</li>
<li><strong>Resource Leakage:</strong>
<ul>
<li>If a thread has allocated resources (such as dynamic memory or file handles) and the program terminates without waiting for the thread to finish, those resources may be leaked. The operating system may not have a chance to clean up resources associated with the thread.</li>
</ul>
</li>
<li><strong>Undefined Behavior:</strong>
<ul>
<li>If the main thread exits while other threads are still executing, it leads to undefined behavior. This means that the behavior of the program cannot be predicted, and it may vary across different systems and compiler implementations.</li>
</ul>
</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello from thead &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; vectorThread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        vectorThread.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(hello));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread waits for other threads&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">/* Each threads in the vector must be accessed by reference */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;thread : vectorThread) thread.<span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="color:red"><strong>Note: Each thread is pushed into the vector by rvalue reference. We have to access each thread in the vector by reference!</strong> </span></p>
<h4 id="Detach">Detach</h4>
<blockquote>
<p>What is a daemon threaad?</p>
<p>A daemon thread is a type of thread that runs in the background, providing support to non-daemon threads. The key characteristic of daemon threads is that they do not prevent the program from exiting, even if they are still running. In other words, daemon threads do not keep the program alive.</p>
<p><strong>Program Termination:</strong></p>
<ul>
<li>If all non-daemon threads in a program complete their execution, the program is allowed to terminate, regardless of whether daemon threads are still running.</li>
<li>Daemon threads are typically used for tasks that should not prevent the program from exiting, such as background tasks, maintenance activities, or supporting tasks.</li>
</ul>
<p><strong>Some pointer to notice</strong>:</p>
<ul>
<li><strong>Automatic Termination:</strong>
<ul>
<li>Daemon threads are designed to be terminated automatically when the program exits, regardless of whether they have completed their tasks.</li>
</ul>
</li>
<li><strong>Resource Cleanup:</strong>
<ul>
<li>The abrupt termination of daemon threads may result in incomplete cleanup of resources. For example, if a daemon thread is responsible for managing resources like file handles or network connections, those resources may not be properly released.</li>
</ul>
</li>
</ul>
</blockquote>
<p>By detaching, we convert threads into <strong>daemon</strong> or background threads.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a Thread</span></span><br><span class="line"><span class="function">std::thread <span class="title">th</span><span class="params">(funcPtr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detach the thread i.e.</span></span><br><span class="line"><span class="comment">// thread will not be joinable now</span></span><br><span class="line">th.<span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure>
<h4 id="Important-Points-about-join-and-detach-functions">Important Points about join() and detach() functions</h4>
<ul>
<li><strong>Never invoke <code>join()</code> or <code>detach()</code> on a thread object that isn’t associated with an executing thread</strong>: When the <code>join()</code> method is called on a thread object, it waits for the associated thread to finish its execution. Once <code>join()</code> has been executed, the thread object is disassociated from any executing thread. Invoking <code>join()</code> again on such an object would crash the program.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">threadObj</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line"></span><br><span class="line">threadObj.<span class="built_in">join</span>();</span><br><span class="line">threadObj.<span class="built_in">join</span>(); <span class="comment">// It will cause Program to Terminate</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Avoid calling <code>detach()</code> repeatedly</strong>: Calling <code>detach()</code> on a thread object detaches the thread object from its executing function. If <code>detach()</code> is invoked twice on the same thread object, the program will crash.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">threadObj</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line"></span><br><span class="line">threadObj.<span class="built_in">detach</span>();</span><br><span class="line">threadObj.<span class="built_in">detach</span>(); <span class="comment">// It will cause Program to Terminate</span></span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">threadObj</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line"></span><br><span class="line">threadObj.<span class="built_in">join</span>();</span><br><span class="line">threadObj.<span class="built_in">detach</span>(); <span class="comment">// It will cause Program to Terminate</span></span><br></pre></td></tr></table></figure>
<ul>
<li>To ensure safety before calling <code>join()</code> or <code>detach()</code>, it’s advisable to check if the thread is joinable using the <code>joinable()</code> method, as demonstrated in the given example.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create thread object</span></span><br><span class="line"><span class="function">std::thread <span class="title">threadObj</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if thread is joinable</span></span><br><span class="line"><span class="keyword">if</span>(threadObj.<span class="built_in">joinable</span>())</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Detaching Thread &quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    threadObj.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if thread is joinable</span></span><br><span class="line"><span class="keyword">if</span>(threadObj.<span class="built_in">joinable</span>())    </span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Detaching Thread &quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    threadObj.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create thread object</span></span><br><span class="line"><span class="function">std::thread <span class="title">threadObj2</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if thread is joinable</span></span><br><span class="line"><span class="keyword">if</span>(threadObj2.<span class="built_in">joinable</span>())</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Joining Thread &quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    threadObj2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if thread is joinable</span></span><br><span class="line"><span class="keyword">if</span>(threadObj2.<span class="built_in">joinable</span>())    </span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Joining Thread &quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    threadObj2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Never-forget-to-call-either-join-or-detach">Never forget to call either join() or detach()</h4>
<p>If neither <code>join()</code> nor <code>detach()</code> is called on a <code>std::thread</code> object that has an associated executing thread, then the program will terminate when that thread object’s destructor is invoked. This is because the destructor checks if the thread is still joinable; if it is, the program is forcibly terminated to avoid undefined behavior. For example,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkerThread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Worker Thread &quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">threadObj</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line">    <span class="comment">// Program will terminate as we have&#x27;t called either join or detach with the std::thread object.</span></span><br><span class="line">    <span class="comment">// Hence std::thread&#x27;s object destructor will terminate the program</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">terminate called without an active exception</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure>
<h4 id="Thread-and-RAII-in-C-11-C-14">Thread and RAII in C++11 / C++14</h4>
<p>We should not forget call either join() or detach() in case of exceptions, otherwise it can terminate the program. To prevents with we should use <span style="color:blue"><strong>RESOURCE ACQUISITION IS INITIALIZATION (RAII)</strong></span> i.e.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadRAII</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::thread &amp;m_thread;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadRAII</span>(std::thread &amp;thread) : <span class="built_in">m_thread</span>(thread) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">ThreadRAII</span>(<span class="type">void</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_thread.<span class="built_in">joinable</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; m_thread.<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; is joinable&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            m_thread.<span class="built_in">detach</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello from a thread&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">erge</span><span class="params">(hello)</span></span>;</span><br><span class="line">    <span class="function">ThreadRAII <span class="title">dalin</span><span class="params">(erge)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="color:red"><strong>Note: <code>m_thread</code> is a reference to <code>std::thread</code>, so we have to use initializer list to initialize it.</strong> </span></p>
<h3 id="Carefully-Pass-Arguments-to-Threads">Carefully Pass Arguments to Threads</h3>
<p>To Pass arguments to thread’s associated callable object or function just pass additional arguments to the <code>std::thread</code> constructor.<br>
<strong>By default the passed arguments are allocated on thread stack.</strong></p>
<h4 id="Passing-simple-arguments-to-a-std-thread-in-C-11"><strong>Passing simple arguments to a std::thread in C++11</strong></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadCallback</span><span class="params">(<span class="type">int</span> x, std::string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Passed Number = &quot;</span>&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Passed String = &quot;</span>&lt;&lt;str&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    std::string str = <span class="string">&quot;Sample String&quot;</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">threadObj</span><span class="params">(threadCallback, x, str)</span></span>;</span><br><span class="line">    threadObj.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="How-not-to-pass-arguments-to-threads-in-C-11">How not to pass arguments to threads in C++11</h4>
<p>Don’t pass addresses of variables from local stack to thread’s callback function.</p>
<p>Because it might be possible that local variable in Thread 1 goes out of scope but Thread 2 is still trying to access it through it’s address.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change_value</span><span class="params">(<span class="type">int</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside new thread i = &quot;</span> &lt;&lt; *val &lt;&lt; std::endl;</span><br><span class="line">    std::<span class="function">chrono::microseconds <span class="title">dura</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(dura);</span><br><span class="line"></span><br><span class="line">    *val = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside new thread i = &quot;</span> &lt;&lt; *val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_thread</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside main thread i = &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::thread <span class="title">dalin</span><span class="params">(change_value, &amp;i)</span></span>;</span><br><span class="line">    dalin.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">create_thread</span>();</span><br><span class="line"></span><br><span class="line">   std::<span class="function">chrono::microseconds <span class="title">dura</span><span class="params">(<span class="number">2000</span>)</span></span>;</span><br><span class="line">   std::this_thread::<span class="built_in">sleep_for</span>(dura);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inside main thread i = 10</span><br><span class="line">Inside new thread i = 0</span><br><span class="line">Inside new thread i = 100</span><br></pre></td></tr></table></figure>
<p>Similarly be careful while passing pointer to memory located on heap to thread. Because it might be possible that some thread deletes that memory before new thread tries to access it.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change_value</span><span class="params">(<span class="type">int</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside new thread i = &quot;</span> &lt;&lt; *val &lt;&lt; std::endl;</span><br><span class="line">    std::<span class="function">chrono::microseconds <span class="title">dura</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(dura);</span><br><span class="line"></span><br><span class="line">    *val = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside new thread i = &quot;</span> &lt;&lt; *val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_thread</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *i = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside main thread i = &quot;</span> &lt;&lt; *i &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::thread <span class="title">dalin</span><span class="params">(change_value, i)</span></span>;</span><br><span class="line">    dalin.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">create_thread</span>();</span><br><span class="line"></span><br><span class="line">   std::<span class="function">chrono::microseconds <span class="title">dura</span><span class="params">(<span class="number">2000</span>)</span></span>;</span><br><span class="line">   std::this_thread::<span class="built_in">sleep_for</span>(dura);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inside main thread i = 10</span><br><span class="line">Inside new thread i = 1543846380</span><br><span class="line">Inside new thread i = 100</span><br></pre></td></tr></table></figure>
<h4 id="How-to-pass-references-to-std-thread-in-C-11">How to pass references to std::thread in C++11</h4>
<p>As arguments are copied to new threads stack so, if you need to pass references in common way i.e.</p>
<p>Consider the following code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadCallback</span><span class="params">(<span class="type">int</span> <span class="type">const</span> &amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> &amp; y = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> &amp;&gt;(x);</span><br><span class="line">    y++;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Inside Thread x = &quot;</span>&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">9</span>;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;In Main Thread : Before Thread Start x = &quot;</span>&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">    <span class="function">std::thread <span class="title">threadObj</span><span class="params">(threadCallback, x)</span></span>;</span><br><span class="line">    threadObj.<span class="built_in">join</span>();</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;In Main Thread : After Thread Joins x = &quot;</span>&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Outpout:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In Main Thread : Before Thread Start x = 9</span><br><span class="line">Inside Thread x = 10</span><br><span class="line">In Main Thread : After Thread Joins x = 9</span><br></pre></td></tr></table></figure>
<p>Even if the callback of the new thread accepts a reference, but the change did not happen in the main thread. It is because <code>x</code> in the new thread is a reference to the copied temporary value on the new thread’s stack.</p>
<p>How to fix this? Using <code>std::ref()</code> i.e.</p>
<p><code>std::ref()</code>: since references are not copyable, <code>std::ref()</code> provides a way to store references in containers, which typically requests copyable objects.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadCallback</span><span class="params">(<span class="type">int</span> <span class="type">const</span> &amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> &amp; y = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> &amp;&gt;(x);</span><br><span class="line">    y++;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Inside Thread x = &quot;</span>&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">9</span>;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;In Main Thread : Before Thread Start x = &quot;</span>&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">    <span class="function">std::thread <span class="title">threadObj</span><span class="params">(threadCallback,std::ref(x))</span></span>;</span><br><span class="line">    threadObj.<span class="built_in">join</span>();</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;In Main Thread : After Thread Joins x = &quot;</span>&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In Main Thread : Before Thread Start x = 9</span><br><span class="line">Inside Thread x = 10</span><br><span class="line">In Main Thread : After Thread Joins x = 10</span><br></pre></td></tr></table></figure>
<h4 id="Assigning-pointer-to-member-function-of-a-class-as-thread-function">Assigning pointer to member function of a class as thread function:</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DummyClass</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DummyClass</span>()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="built_in">DummyClass</span>(<span class="type">const</span> DummyClass &amp; obj)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sampleMemberFunction</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Inside sampleMemberFunction &quot;</span>&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    DummyClass dummyObj;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">threadObj</span><span class="params">(&amp;DummyClass::sampleMemberFunction,&amp;dummyObj, x)</span></span>;</span><br><span class="line">    threadObj.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note: The callback of <code>threadObj</code> is the member function of the instance <code>dummObj</code>, hence the address of <code>dummyObj</code> is required.</p>
<h3 id="Data-Sharing-and-Race-Conditions">Data Sharing and Race Conditions</h3>
<h4 id="A-Practical-example-of-Race-Condition">A Practical example of Race Condition:</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wallet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mMoney;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Wallet</span>() :<span class="built_in">mMoney</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mMoney; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addMoney</span><span class="params">(<span class="type">int</span> money)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; money; ++i) mMoney++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Now Let’s create 5 threads and all these threads will share a same object of class Wallet and add 1000 to internal money using it’s <code>addMoney()</code> member function in parallel.</p>
<p>So, if initially money in wallet is 0. Then after completion of all thread’s execution money in Wallet should be 5000.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">testMultithreadedWallet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Wallet walletObject;</span><br><span class="line">   std::vector&lt;std::thread&gt; threads;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)&#123;</span><br><span class="line">        threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(&amp;Wallet::addMoney, &amp;walletObject, <span class="number">1000</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; threads.<span class="built_in">size</span>() ; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       threads.<span class="built_in">at</span>(i).<span class="built_in">join</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> walletObject.<span class="built_in">getMoney</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1000</span>; k++)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">if</span>((val = <span class="built_in">testMultithreadedWallet</span>()) != <span class="number">5000</span>)</span><br><span class="line">     &#123;</span><br><span class="line">       std::cout &lt;&lt; <span class="string">&quot;Error at count = &quot;</span>&lt;&lt;k&lt;&lt;<span class="string">&quot; Money in Wallet = &quot;</span>&lt;&lt;val &lt;&lt; std::endl;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Error at count = 176 Money in Wallet = 4695</span><br><span class="line">Error at count = 260 Money in Wallet = 3987</span><br><span class="line">Error at count = 286 Money in Wallet = 4666</span><br><span class="line">Error at count = 321 Money in Wallet = 4904</span><br><span class="line">Error at count = 700 Money in Wallet = 4401</span><br></pre></td></tr></table></figure>
<p><strong>The outputs are different each time we run the program.</strong></p>
<h3 id="Using-mutex-to-fix-Race-Conditions">Using mutex to fix Race Conditions</h3>
<p><span style="color:orange"> <strong><code>std::mutex</code> is used as a binary semaphore.</strong> </span></p>
<h4 id="std-mutex"><code>std::mutex</code></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>There are two important methods of mutex:</p>
<ol>
<li><code>lock()</code></li>
<li><code>unlock()</code></li>
</ol>
<p>Add an  instance of <code>std::mutex</code> to <code>Wallet</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wallet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mMoney;</span><br><span class="line">    std::mutex mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Wallet</span>() :<span class="built_in">mMoney</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMoney</span><span class="params">()</span>   </span>&#123;     <span class="keyword">return</span> mMoney; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addMoney</span><span class="params">(<span class="type">int</span> money)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; money; ++i) mMoney++;</span><br><span class="line">        mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="std-lock-guard"><code>std::lock_guard</code></h4>
<p>But what if we forgot to unlock the mutex at the end of function. In such scenario, one thread will exit without releasing the lock and other threads will remain in waiting. <strong>Or, an exception occurs after the thread locks the mutex.</strong></p>
<p>To avoid such scenarios we should use <code>std::lock_guard</code>.</p>
<p><code>std::lock_guard</code> is a class template, which implements the RAII for mutex. It wraps the mutex inside it’s object and locks the attached mutex in its constructor. When it’s destructor is called it releases the mutex.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wallet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mMoney;</span><br><span class="line">    std::mutex mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Wallet</span>() :<span class="built_in">mMoney</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMoney</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> mMoney; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addMoney</span><span class="params">(<span class="type">int</span> money)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lockGuard</span><span class="params">(mutex)</span></span>;</span><br><span class="line">        <span class="comment">// In constructor it locks the mutex</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; money; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// If some exception occurs at this</span></span><br><span class="line">            <span class="comment">// point then destructor of lockGuard</span></span><br><span class="line">            <span class="comment">// will be called due to stack unwinding.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            mMoney++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Once function exits, then destructor</span></span><br><span class="line">        <span class="comment">// of lockGuard Object will be called.</span></span><br><span class="line">        <span class="comment">// In destructor it unlocks the mutex.</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="std-unique-lock"><code>std::unique_lock</code></h4>
<p><code>std::unique_lock</code> is more flexible. It allows you to construct an unlocked <code>std::unique_lock</code> and later lock/unlock the associated mutex explicitly. This flexibility is useful in scenarios where you need to conditionally acquire or release locks.</p>
<p>As with <code>std::lock_guard</code>,  <code>std::unique_lock</code> acquire the associated lock upon construction.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">exampleUsingUniqueLock</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(myMutex)</span></span>;</span><br><span class="line">    <span class="comment">// Critical section</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside critical section&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="comment">// lock is automatically released when unique_lock goes out of scop</span></span><br></pre></td></tr></table></figure>
<h3 id="Event-Handling">Event Handling</h3>
<p>Sometimes a thread needs to wait for an event to happen like a condition to become true or for  a task to be completed by another thread.</p>
<p>Suppose we are building a network based application. This application does following tasks,</p>
<ol>
<li>Perform some handshaking with server</li>
<li>Load Data from XML files.</li>
<li>Do processing on data loaded from XML.</li>
</ol>
<p>As we can see that Task 1 is not dependent on any other Tasks but Task 3 is dependent on Task 2. So, it means that Task1 and Task2 can run in parallel on different threads to improve the performance.</p>
<p>So, let’s break this into a multi-threaded application,</p>
<p>Now, it includes two threads,</p>
<p>Responsibilities of Thread 1 are,</p>
<ul>
<li>Perform some handshaking with server.</li>
<li>Wait for data to be loaded from XML by Thread 2</li>
<li>Do processing on data loaded from XML.</li>
</ul>
<p>Responsibilities of Thread 2 are,</p>
<ul>
<li>Load data from XML</li>
<li>Notify another Thread</li>
</ul>
<img src="https://raw.githubusercontent.com/JosiahLi/MarkdownPictures/main/first.png" alt="Multithreaded Application" style="zoom:67%;" />
<p>But how do we achieve it?</p>
<h3 id="Condition-Variables-Explained">Condition Variables Explained</h3>
<p>Condition Variable is a kind of Event used for signaling between two or more threads.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>A mutex is required along with condition variable.</strong></p>
<h4 id="wait"><code>wait</code></h4>
<p><code>std::condition_variable::wait</code>: used by a thread to wait until it is notified by another thread. This method is typically associated with a mutex to synchronize access to shared data.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">( std::unique_lock&lt;std::mutex&gt;&amp; lock )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>(1) <strong>Atomically</strong> releases <code>lock</code>, blocks the current executing thread, and adds it to the list of threads waiting on <code>*this</code>. The thread will be unblocked when <code>notify_one()</code> or <code>notify_all()</code> is executed. It may also be unblocked spuriously. When unblocked, regardless of the reason, <code>lock</code> is reacquired and <code>wait</code> exits.</li>
</ul>
<p><span style="color:red"> <strong>Note: <code>wait()</code> release lock before the current thread enters a waiting state.</strong></span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Predicate &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">( std::unique_lock&lt;std::mutex&gt;&amp; lock, Predicate pred )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>Equivalent to <code>while (!pred()) wait(lock);</code>.</li>
<li>This overload may be used to ignore spurious awakenings while waiting for a specific condition to become true. <span style="color:red"><strong>Note that before enter to this method <code>lock</code> must be acquired</strong></span>, after <code>wait(lock)</code> exits it is also reacquired</li>
<li><code>lock</code> can be used as a guard to <code>pred()</code> access, since there are shared variables inside <code>pred()</code>. If <code>pred()</code> return <code>false</code>, blocking the current thread and release <code>lock</code>. If <code>pred()</code> return <code>true</code>, reacquiring <code>lock</code> and unblocking the current thread.</li>
</ul>
<h4 id="notify-one"><code>notify_one</code></h4>
<p><code>std::condition_variable</code> : used to notify one waiting thread that the condition they are waiting for may have been met.</p>
<h4 id="notify-all"><code>notify_all</code></h4>
<p><code>std::condition_variable</code>: used to notify all waiting threads that the condition they are waiting for may have been met.</p>
<h4 id="Example-1-2">Example 1</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    std::mutex m_mutex;</span><br><span class="line">    std::condition_variable m_condVar;</span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">void</span>) &#123; flag = <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">t_lock</span><span class="params">(m_mutex)</span></span>; <span class="comment">/* acquire lock */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Block until flag becomes true.</span></span><br><span class="line"><span class="comment">            If flag is false, blocking and releasing the lock.</span></span><br><span class="line"><span class="comment">            Once flag becomes true, reacquire the block and unblock.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        m_condVar.<span class="built_in">wait</span>(t_lock, [&amp;](<span class="type">void</span>) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> flag; &#125;);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker thread got signaled and proceed to work.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) </span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;-----Processing data-----&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Completed work&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">main_thread</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main thread is sleeping for 2 seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">/* Note: we have to surround the shared variable with braces */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">t_lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main thread completed preparation&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        m_condVar.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    <span class="function">std::thread <span class="title">main_thread</span><span class="params">(&amp;Test::main_thread, &amp;test)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">worker_thread</span><span class="params">(&amp;Test::worker_thread, &amp;test)</span></span>;</span><br><span class="line">    <span class="comment">/* DO NOT forget to reap peer threads */</span> </span><br><span class="line">    main_thread.<span class="built_in">join</span>();</span><br><span class="line">    worker_thread.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>std::bind</code>is a powerful tool in C++ that allows you to create function objects with placeholders for arguments. It comes from the <code>&lt;functional&gt;</code> header .</p>
</blockquote>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> bind_function = std::<span class="built_in">bind</span>(foo, <span class="number">10</span>, std::placeholders::_1, <span class="number">30</span>);</span><br><span class="line">    <span class="built_in">bind_function</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10, 200, 30</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Actually, we can replace the lambda function with <code>std::bind</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">predicate</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m_condVar.<span class="built_in">wait</span>(t_lock, std::<span class="built_in">bind</span>(&amp;Test::predicate, <span class="keyword">this</span>));</span><br></pre></td></tr></table></figure>
<h4 id="Relation-with-semaphore">Relation with semaphore</h4>
<p>In fact, <span style="color:blue">We can think of <code>std::condition_variable::wait()</code> and <code>std::condition_variable::notify_one()</code>, respectively, as <code>P(&amp;semaphore)</code> and <code>V(&amp;semaphore)</code> </span> where the <code>semaphore</code> is initialized to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>.</p>
<h4 id="Example-2-semaphore">Example 2 (semaphore)</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    std::mutex m_mutex;</span><br><span class="line">    std::condition_variable m_condVar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">t_lock</span><span class="params">(m_mutex, std::defer_lock)</span></span>; <span class="comment">/* Note: yet not acquire the lock */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        m_condVar.<span class="built_in">wait</span>(t_lock); <span class="comment">/* P(&amp;semaphore) */</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker thread got signaled and proceed to work.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) </span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;-----Processing data-----&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Completed work&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">main_thread</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main thread is sleeping for 2 seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">/* Note: we have to surround the shared variable with braces */</span></span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main thread completed preparation&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        m_condVar.<span class="built_in">notify_one</span>(); <span class="comment">/* V(&amp;semaphore) */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="std-future-std-promise-and-Returning-values-from-Thread"><code>std::future</code> , <code>std::promise</code> and Returning values from Thread</h3>
<p>Many times we encounter a situation where we want a thread to return a result.</p>
<p>There are two ways to do such work.</p>
<p><strong>Old Way : Share data among threads using pointer</strong></p>
<ul>
<li>To do such a simple thing we used a condition variable, a mutex and a pointer i.e. 3 items to catch a returned value.</li>
</ul>
<p><strong>C++11 Way : Using <code>std::future</code> and <code>std::promise</code></strong></p>
<ul>
<li><code>std::future</code> is used for asynchronous programming. It represents a handle to a value that may not be available yet but will be in the future. This is particularly useful for tasks that may take some time to complete, such as I/O operations or computations.</li>
<li><code>std::promise</code> is a class template in C++ that provides a convenient way to set a value or an exception in one thread and make it available for retrieval in another thread through a corresponding <code>std::future</code>.</li>
</ul>
<p>Suppose we create an object of <code>std::primise</code> in thread <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> &lt;future&lt;</span></span><br><span class="line">std::promise&lt;<span class="type">int</span>&gt; promiseObj;</span><br></pre></td></tr></table></figure>
<p><span style="color:blue"><strong>As of now, <code>promiseObj</code> is not associated with any value. But It promises that the associated value will be set at some point of time. Once the value has been set, we can  retrieve it using <code>std::future</code>.</strong></span></p>
<p>And suppose that we have passed <code>promiseObj</code> to thread <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>. The problem is when thread 2 is going to set the value associated with <code>promiseObj</code>.</p>
<p>Each <code>std::promise</code> has an associated <code>std::future</code> through which the thread can get the associated value.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;<span class="type">int</span>&gt; futureObj = promiseObj.<span class="built_in">get_future</span>();</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = futureObj.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>
<p>Thread <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> will be blocked until thread <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> or other threads set the associated value.</p>
<p>In thread <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>, we can set the value,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promiseObj.<span class="built_in">set_value</span>(<span class="number">45</span>);</span><br></pre></td></tr></table></figure>
<h4 id="Example">Example</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initializer</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt; *promise)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;initialized is setting the associated value&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    promise-&gt;<span class="built_in">set_value</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;sleep for one second (&quot;</span> &lt;&lt; i  &lt;&lt; <span class="string">&quot;/3)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; promiseObj;</span><br><span class="line">    <span class="keyword">auto</span> futureObj = promiseObj.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">threadObj</span><span class="params">(initializer, &amp;promiseObj)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; futureObj.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    threadObj.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initialized is setting the associated value</span><br><span class="line">sleep for one second (1/3)</span><br><span class="line">100</span><br><span class="line">sleep for one second (2/3)</span><br><span class="line">sleep for one second (3/3)</span><br></pre></td></tr></table></figure>
<h3 id="std-async"><code>std::async</code></h3>
<p>The <code>std::async</code> function in C++ is used to launch a function asynchronously. It simplifies manual call to <code>std::promise</code> and <code>std::future</code>, this is, it will help us create <code>std::promise</code> and <code>std::future</code> internally.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Function</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">std::future&lt;std::<span class="type">result_of_t</span>&lt;<span class="built_in">Function</span>(Args...)&gt;&gt; <span class="built_in">async</span>(std::launch policy, Function&amp;&amp; f, Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure>
<p><strong><code>policy</code></strong>: Specifies the launch policy, which determines how the asynchronous task is executed. It can be one of the following:</p>
<ul>
<li><code>std::launch::async</code>: The task is executed asynchronously. This is, it creates a asynchronous thread to implement the callback.</li>
<li><code>std::launch::deferred</code>: The task is executed when the result is requested using <code>get()</code>.</li>
<li><code>std::launch::async | std::launch::deferred</code>: By default.</li>
</ul>
<p><strong><code>Function</code></strong>: The type of the function or callable object that will be executed asynchronously.</p>
<ul>
<li>Function Pointer</li>
<li>Function Object</li>
<li>Lambda Function</li>
</ul>
<p><strong><code>Args...</code></strong>: The types of the arguments that will be passed to the function.</p>
<p><strong><code>std::result_of_t&lt;Function(Args...)&gt;</code></strong>: The return type of the function.</p>
<p><strong><code>f</code></strong>: The function or callable object that will be executed asynchronously.</p>
<p><strong><code>args...</code></strong>: The arguments that will be passed to the function when it is called.</p>
<p><strong>Return value</strong>: It returns a <code>std::future</code> object that represents the asynchronous task’s result. You can use this <code>std::future</code> to retrieve the result or handle exceptions.</p>
<h4 id="Example-2">Example</h4>
<p>Suppose that we have to fetch data from both database and file system.</p>
<p>If we implement it by single thread,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">fetchDataFromDB</span><span class="params">(std::string recvdData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Make sure that function takes 5 seconds to complete</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Do stuff like creating DB Connection and fetching Data</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;DB_&quot;</span> + recvdData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">fetchDataFromFile</span><span class="params">(std::string recvdData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Make sure that function takes 5 seconds to complete</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Do stuff like fetching Data File</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;File_&quot;</span> + recvdData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Get Start Time</span></span><br><span class="line">    system_clock::time_point start = system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Fetch Data from DB</span></span><br><span class="line">    std::string dbData = <span class="built_in">fetchDataFromDB</span>(<span class="string">&quot;Data&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Fetch Data from File</span></span><br><span class="line">    std::string fileData = <span class="built_in">fetchDataFromFile</span>(<span class="string">&quot;Data&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get End Time</span></span><br><span class="line">    <span class="keyword">auto</span> end = system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> diff = duration_cast &lt; std::chrono::seconds &gt; (end - start).<span class="built_in">count</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Total Time Taken = &quot;</span> &lt;&lt; diff &lt;&lt; <span class="string">&quot; Seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Combine The Data</span></span><br><span class="line">    std::string data = dbData + <span class="string">&quot; :: &quot;</span> + fileData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Printing the combined Data</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Data = &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Total Time Taken = <span class="number">10</span> Seconds</span><br><span class="line">Data = DB_Data :: File_Data</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">fetchDataFromDB</span><span class="params">(std::string recvdData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Make sure that function takes 5 seconds to complete</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Do stuff like creating DB Connection and fetching Data</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;DB_&quot;</span> + recvdData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">fetchDataFromFile</span><span class="params">(std::string recvdData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Make sure that function takes 5 seconds to complete</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Do stuff like fetching Data File</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;File_&quot;</span> + recvdData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Get Start Time</span></span><br><span class="line">    system_clock::time_point start = system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Fetch Data from DB</span></span><br><span class="line">    std::future&lt;std::string&gt; futureDB = std::<span class="built_in">async</span>(std::launch::async, fetchDataFromDB, <span class="string">&quot;Data&quot;</span>);</span><br><span class="line">    <span class="comment">//Fetch Data from File</span></span><br><span class="line">    std::string fileData = <span class="built_in">fetchDataFromFile</span>(<span class="string">&quot;Data&quot;</span>);</span><br><span class="line">    <span class="comment">// Get End Time</span></span><br><span class="line">    <span class="keyword">auto</span> end = system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> diff = duration_cast &lt; std::chrono::seconds &gt; (end - start).<span class="built_in">count</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Total Time Taken = &quot;</span> &lt;&lt; diff &lt;&lt; <span class="string">&quot; Seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Combine The Data</span></span><br><span class="line">    std::string data = futureDB.<span class="built_in">get</span>() + <span class="string">&quot; :: &quot;</span> + fileData; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//Printing the combined Data</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Data = &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Total Time Taken = 5 Seconds</span><br><span class="line">Data = DB_Data :: File_Data</span><br></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/12/23/Cmake-Tutorial/" title="Cmake Tutorial"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">Cmake Tutorial</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">LI LIANGJI</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/JosiahLi" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Initializer-List"><span class="toc-number">1.</span> <span class="toc-text">Initializer List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Namespace"><span class="toc-number">2.</span> <span class="toc-text">Namespace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda-Function"><span class="toc-number">3.</span> <span class="toc-text">Lambda Function</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Example-1"><span class="toc-number">3.1.</span> <span class="toc-text">Example 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Example-2"><span class="toc-number">3.2.</span> <span class="toc-text">Example 2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Example-3"><span class="toc-number">3.3.</span> <span class="toc-text">Example 3</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Variadic-Templates"><span class="toc-number">4.</span> <span class="toc-text">Variadic Templates</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#What-is-RAII"><span class="toc-number">5.</span> <span class="toc-text">What is RAII</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Smart-Pointer"><span class="toc-number">6.</span> <span class="toc-text">Smart Pointer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr"><span class="toc-number">6.1.</span> <span class="toc-text">unique_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Create"><span class="toc-number">6.1.1.</span> <span class="toc-text">Create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Can-a-unique-pointer-be-copied"><span class="toc-number">6.1.2.</span> <span class="toc-text">Can a unique pointer be copied?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reset-renounce-a-unique-pointer"><span class="toc-number">6.1.3.</span> <span class="toc-text">Reset (renounce) a unique pointer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pass-a-unique-pointer-to-a-function"><span class="toc-number">6.1.4.</span> <span class="toc-text">Pass a unique pointer to a function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Return-unique-ptr-from-a-function-in-C"><span class="toc-number">6.1.5.</span> <span class="toc-text">Return unique_ptr from a function in C++</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Use-unique-ptr-with-Arrays"><span class="toc-number">6.1.6.</span> <span class="toc-text">Use unique_ptr with Arrays</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr"><span class="toc-number">6.2.</span> <span class="toc-text">shared_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Create-2"><span class="toc-number">6.2.1.</span> <span class="toc-text">Create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#How-shared-ptr-works"><span class="toc-number">6.2.2.</span> <span class="toc-text">How shared_ptr works?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#How-to-Check-Reference-Count-of-a-shared-ptr-Object"><span class="toc-number">6.2.3.</span> <span class="toc-text">How to Check Reference Count of a shared_ptr Object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Using-std-make-shared-for-creating"><span class="toc-number">6.2.4.</span> <span class="toc-text">Using std::make_shared for creating</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Detaching-the-Associated-Raw-Pointer-from-shared-ptr"><span class="toc-number">6.2.5.</span> <span class="toc-text">Detaching the Associated Raw Pointer from shared_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dereferencing-a-shared-ptr"><span class="toc-number">6.2.6.</span> <span class="toc-text">Dereferencing a shared_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Comparison-Operations-with-shared-ptr"><span class="toc-number">6.2.7.</span> <span class="toc-text">Comparison Operations with shared_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Complete-Example-of-shared-ptr"><span class="toc-number">6.2.8.</span> <span class="toc-text">Complete Example of shared_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Using-shared-ptr-with-Arrays-in-C"><span class="toc-number">6.2.9.</span> <span class="toc-text">Using shared_ptr with Arrays in C++</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Using-a-Normal-Function-as-Custom-Deleter-in-shared-ptr"><span class="toc-number">6.2.10.</span> <span class="toc-text">Using a Normal Function as Custom Deleter in shared_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Using-a-Lambda-Function-as-Custom-Deleter-in-shared-ptr"><span class="toc-number">6.2.11.</span> <span class="toc-text">Using a Lambda Function as Custom Deleter in shared_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Smart-Pointer-vs-Raw-Pointer-in-C"><span class="toc-number">6.2.12.</span> <span class="toc-text">Smart Pointer vs Raw Pointer in C++</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Get-the-corresponding-raw-pointer"><span class="toc-number">6.2.13.</span> <span class="toc-text">Get the corresponding raw pointer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#How-not-to-use-Smart-Pointers-in-C"><span class="toc-number">6.2.14.</span> <span class="toc-text">How not to use Smart Pointers in C++?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Recommended-Practices-for-Smart-Pointers-in-C"><span class="toc-number">6.2.15.</span> <span class="toc-text">Recommended Practices for Smart Pointers in C++</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weak-ptr"><span class="toc-number">6.3.</span> <span class="toc-text">weak_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Case-Study-1-Creating-Binary-Tree-with-shared-ptr"><span class="toc-number">6.3.1.</span> <span class="toc-text">Case Study 1: Creating Binary Tree with shared_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Problem-Introducing-Parent-Pointers"><span class="toc-number">6.3.2.</span> <span class="toc-text">Problem: Introducing Parent Pointers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Case-Study-2-Linked-List"><span class="toc-number">6.3.3.</span> <span class="toc-text">Case Study 2: Linked List</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-Using-weak-ptr-Smart-Pointer"><span class="toc-number">6.3.4.</span> <span class="toc-text">Solution: Using weak_ptr Smart Pointer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Improved-Binary-Tree-Example"><span class="toc-number">6.3.5.</span> <span class="toc-text">Improved Binary Tree Example</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rvalue-Reference-Move-Constructor"><span class="toc-number">7.</span> <span class="toc-text">Rvalue Reference &amp; Move Constructor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Declaring-rvalue-reference"><span class="toc-number">7.1.</span> <span class="toc-text">Declaring rvalue reference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Problem-of-Temporary-Objects"><span class="toc-number">7.2.</span> <span class="toc-text">Problem of Temporary Objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Solving-Problem-of-Temporary-Objects"><span class="toc-number">7.3.</span> <span class="toc-text">Solving Problem of Temporary Objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Is-rvalue-immutable-in-C"><span class="toc-number">7.4.</span> <span class="toc-text">Is rvalue immutable in C++?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Concurrency-in-C"><span class="toc-number">8.</span> <span class="toc-text">Concurrency in C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread-Creation-in-C-11"><span class="toc-number">8.1.</span> <span class="toc-text">Thread Creation in C++11</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Creating-a-thread-using-Normal-Function"><span class="toc-number">8.1.1.</span> <span class="toc-text">Creating a thread using Normal Function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Creating-a-thread-using-Function-Objects"><span class="toc-number">8.1.2.</span> <span class="toc-text">Creating a thread using Function Objects</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Creating-a-thread-using-Lambda-functions"><span class="toc-number">8.1.3.</span> <span class="toc-text">Creating a thread using Lambda functions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Differentiating-between-threads-using-Thread-ID"><span class="toc-number">8.1.4.</span> <span class="toc-text">Differentiating between threads using Thread ID</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Join-Detach-Threads"><span class="toc-number">8.2.</span> <span class="toc-text">Join &amp; Detach Threads</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Join"><span class="toc-number">8.2.1.</span> <span class="toc-text">Join</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Detach"><span class="toc-number">8.2.2.</span> <span class="toc-text">Detach</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Important-Points-about-join-and-detach-functions"><span class="toc-number">8.2.3.</span> <span class="toc-text">Important Points about join() and detach() functions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Never-forget-to-call-either-join-or-detach"><span class="toc-number">8.2.4.</span> <span class="toc-text">Never forget to call either join() or detach()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Thread-and-RAII-in-C-11-C-14"><span class="toc-number">8.2.5.</span> <span class="toc-text">Thread and RAII in C++11 &#x2F; C++14</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Carefully-Pass-Arguments-to-Threads"><span class="toc-number">8.3.</span> <span class="toc-text">Carefully Pass Arguments to Threads</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Passing-simple-arguments-to-a-std-thread-in-C-11"><span class="toc-number">8.3.1.</span> <span class="toc-text">Passing simple arguments to a std::thread in C++11</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#How-not-to-pass-arguments-to-threads-in-C-11"><span class="toc-number">8.3.2.</span> <span class="toc-text">How not to pass arguments to threads in C++11</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#How-to-pass-references-to-std-thread-in-C-11"><span class="toc-number">8.3.3.</span> <span class="toc-text">How to pass references to std::thread in C++11</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Assigning-pointer-to-member-function-of-a-class-as-thread-function"><span class="toc-number">8.3.4.</span> <span class="toc-text">Assigning pointer to member function of a class as thread function:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-Sharing-and-Race-Conditions"><span class="toc-number">8.4.</span> <span class="toc-text">Data Sharing and Race Conditions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-Practical-example-of-Race-Condition"><span class="toc-number">8.4.1.</span> <span class="toc-text">A Practical example of Race Condition:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-mutex-to-fix-Race-Conditions"><span class="toc-number">8.5.</span> <span class="toc-text">Using mutex to fix Race Conditions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#std-mutex"><span class="toc-number">8.5.1.</span> <span class="toc-text">std::mutex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-lock-guard"><span class="toc-number">8.5.2.</span> <span class="toc-text">std::lock_guard</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-unique-lock"><span class="toc-number">8.5.3.</span> <span class="toc-text">std::unique_lock</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Event-Handling"><span class="toc-number">8.6.</span> <span class="toc-text">Event Handling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Condition-Variables-Explained"><span class="toc-number">8.7.</span> <span class="toc-text">Condition Variables Explained</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#wait"><span class="toc-number">8.7.1.</span> <span class="toc-text">wait</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#notify-one"><span class="toc-number">8.7.2.</span> <span class="toc-text">notify_one</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#notify-all"><span class="toc-number">8.7.3.</span> <span class="toc-text">notify_all</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Example-1-2"><span class="toc-number">8.7.4.</span> <span class="toc-text">Example 1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Relation-with-semaphore"><span class="toc-number">8.7.5.</span> <span class="toc-text">Relation with semaphore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Example-2-semaphore"><span class="toc-number">8.7.6.</span> <span class="toc-text">Example 2 (semaphore)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-future-std-promise-and-Returning-values-from-Thread"><span class="toc-number">8.8.</span> <span class="toc-text">std::future , std::promise and Returning values from Thread</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Example"><span class="toc-number">8.8.1.</span> <span class="toc-text">Example</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-async"><span class="toc-number">8.9.</span> <span class="toc-text">std::async</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Example-2"><span class="toc-number">8.9.1.</span> <span class="toc-text">Example</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/24/C++-Notes/" title="C++ Notes">C++ Notes</a><time datetime="2023-12-23T15:23:29.000Z" title="Created 2023-12-24 00:23:29">2023-12-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/23/Cmake-Tutorial/" title="Cmake Tutorial">Cmake Tutorial</a><time datetime="2023-12-23T07:01:31.000Z" title="Created 2023-12-23 16:01:31">2023-12-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/10/Hello-Hexo/" title="Hello Hexo">Hello Hexo</a><time datetime="2023-12-10T13:12:08.000Z" title="Created 2023-12-10 22:12:08">2023-12-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/10/hello-world/" title="Hello World">Hello World</a><time datetime="2023-12-10T12:39:51.697Z" title="Created 2023-12-10 21:39:51">2023-12-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By LI LIANGJI</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>